# Lab1实验报告
## 过程介绍
在本次实验中主要实现了**Task的信息获取**的功能，细分的话包括：
1. 对每个Task系统调用次数的记录与更新
    修改TaskControlBlock结构，增加一个记录系统调用次数的容器
2. 对当前Task的状态查询
    开放一个TaskManager的查询接口
3. 对每个Task的计时
    修改TaskControlBlock结构，新增一个构造时间的属性

## 问答题
### 1

```PlainText
[rustsbi] RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0
[kernel] PageFault in application, bad addr = 0x0, bad instruction = 0x80400414, kernel killed it.
[kernel] IllegalInstruction in application, kernel killed it.
[kernel] IllegalInstruction in application, kernel killed it.
```
`ch2b_bad_address`中在用户态尝试访问无效的内存地址，导致被拦截中止。
`ch2b_bad_insrtuctions`中在用户态尝试使用S态的指令`sret`，越级被拦截。
`ch2b_bad_registers`中在用户态尝试访问S态的`sstatus`寄存器，被拦截

### 2
1. a0存了上下文结构体在内核栈中的地址。 \
    __restore的作用是从栈上的上下文恢复寄存器
2. 特殊处理了 sstatus、sepc 和 sscratch 这三个寄存器。\
    `sstatus`控制CPU的运行模式，特权模式等。进入用户态之前要将该寄存器恢复才能保证CPU正常工作\
    `sepc` 保存触发中断或异常的地址，进入用户态之前也需要将其恢复之前的值，从而保证CPU能从正确的地址开始执行指令\
    `sscratch`存的是用户态和内核态切换的信息，恢复后才能正常的切换到用户态
3. `x2`指向内核栈，用户栈的栈指针保存在`sscratch`中，必须通过`csrr`指令读到通用寄存器中后才能使用，因此我们先考虑保存其它通用寄存器，腾出空间。\
    `x4`除非我们手动出于一些特殊用途使用它，否则一般不会被用到。
4. `sp`寄存器中的值被修改为`sscratch`寄存器的值，并将`sscratch`寄存器的值设置为`sp`寄存器之前的值。这个操作的目的是切换用户态和内存态
5. `sret`执行后切换。`sret`被RISC-V中规定为用于从异常处理和中断处理返回到用户态的指令。\
    在执行`sret`后pc<-sepc，然后修改`sstatus`为用户态
6. 指令执行后，`sp`指向内核栈，`sscratch`存`sp`之前的旧值。交换后以便于执行玩内核态程序后返回用户态
7. `ecall`

## 荣誉准则
1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：\
**无**

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：\
**无**

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

## 踩坑与心得
> 应该是栈溢出吧～

为了实现记录每个task使用系统调用的次数记录，我一开始往TaskControlBlock里加了一个**长500的u32数组**。此后，这将成为挥之不去的阴影。
在提供了更新和查询的接口后，我运行BASE2，神奇的事情发生了：程序无端在输出power7后就不再运行。很长一段时间里我误以为我修改了不该修改的代码，于是我进行了一次推倒重来，依旧没有解决程序卡住的问题。之后，我尝试输出调试，更神奇的事情发生了，我希望输出的字符串打印一半停住了，我在想打印应该是S优先级，不应该被中止。于是我想到了栈溢出（无端联想，因为不会用gdb。。。）。考虑到记录系统调用的数组空间效率太低了，于是我尝试使用哈希表，找到了一个叫BTreeMap的数据结构。当我使用哈希表来代替数组之后，程序就成功跑完了。。。

> 开始做之前先在群里看有没有类似的issue

据说task_info里的时间也是一个坑，但是在开始之前有关注过群聊记录，在做的时候及时修改了，没有踩坑。
