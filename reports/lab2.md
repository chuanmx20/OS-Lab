# Lab2

<center>钏茗喜 &nbsp 2020011035</center>

<HR>

## mmap

mmap就是分配新的内存地址，简单地检查一下参数合法性，对len向上(4096)取整，在分配前检查一下是否已经被map过就行。

大致修改了以下几处：

1. 新增TASKMANAGER接口，用于分配内存给task
2. TaskControlBlock新增mmap接口，检测是否被map过并且成功map后返回0，否则返回-1
3. 新增memory_set的mmap方法，调用InsertFramedArea

## munmap

与mmap相对，munmap要做的就是释放内存并且修改PTE删除被unmap掉的entry。首先检查需要unmap的页里是否存在未被map过的页，没有的话就将每个含有需要unmap的页的area都unmap就行。

大致修改了以下部分代码：

1. 新增TASKMANAGER接口，unmap
2. TaskControlBlock新增munmap接口
3. 新增memory_set的munmap方法，检测是否存在未map页，存在则返回-1，否则就遍历areas来unmap包含被删页的区域。

## sys_task_info和sys_get_time

功能实现上照搬ch3实现方法，不同的是增加了一个虚拟地址转物理地址的过程。

逻辑如下：

1. 新增TASKMANAGER接口，va2pa
2. TaskControlBlock新增va2pa方法
3. 新增memory_set的va2pa方法
4. 在sys_task_info和sys_get_time方法中，将原指针转换为物理地址后填入数据即可(unsafe)

## 思考题

**1. 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？**

在SV39页表中，每一个表项有64位，其中最高的十位属于保留位，全0。最低的十位中从低到高依次是验证位、可读、可写、可执行、用户态位、全局映射位、被访问标记和脏位(V, R, W, X, U, G, A, D)，然后是两位保留位。其余的44位(53-10)存储虚拟页号对应的物理页号或者存储下一级页表的偏移量。

**2.缺页**

**2.1. 请问哪些异常可能是缺页导致的？**

- 无效地址异常：当进程访问的虚拟地址不在其地址空间范围内时，MMU 无法找到对应的页表项，会触发无效地址异常。
- 保护异常：当进程访问的虚拟地址在其地址空间范围内，但是访问权限与页表项中的保护位不匹配时，MMU 会触发保护异常。
- 缺失异常：当进程访问的虚拟地址在其地址空间范围内，且访问权限与页表项中的保护位匹配，但是页表项中的有效位为 0 时，MMU 会触发缺失异常。这表示该页面没有被加载到物理内存中，需要从外部存储器中调入。

**2.2 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。**

- pc: 存储发生异常的指令的地址，用于定位错误源或者重新执行指令。
- scause: 存储异常的原因码，用于区分不同类型的异常。
- stval: 存储发生异常时的虚拟地址，用于查找对应的页表项或者报告错误信息。
- sstatus: 存储异常发生前的状态位，用于保存和恢复中断使能和特权级等信息。
- sepc: 存储异常返回地址，用于恢复进程的执行流程。

**2.3 这样做有哪些好处？**

- 节省内存空间。如果一个程序的某些代码段很少被执行或者根本不会被执行，那么就没有必要将它们加载到内存中，从而减少了内存的占用和浪费。
- 加快程序启动速度。如果一个程序的代码段很大，那么一次性将它们全部加载到内存中会花费较长的时间，从而影响了程序的启动速度。而采用 Lazy 策略，只需要加载程序的入口点和必要的依赖库，就可以开始执行程序，从而提高了程序的启动速度。
- 适应动态变化。如果一个程序在运行过程中需要动态加载或卸载某些代码段，那么采用 Lazy 策略可以更方便地实现这一功能，因为只需要修改页表和磁盘位置信息，而不需要移动或复制内存中的数据。

**2.4 处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？**

每个entry64位也就是8byte，一个页面4096byte，即512个表项。对于叶子结点，没个页面代表了512*4096byte = 2MB，处理10GB需要5000页，大约就需要5000\*4096也就是20MB的内存。

**2.5 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。**

当用户进程申请内存空间时，不立即分配物理页，而是只在虚拟地址空间中标记出已经申请的区域，并设置相应的页表项为不可访问。这样，用户进程就可以认为自己已经获得了所需的内存空间，但实际上并没有占用物理内存资源。

当用户进程访问这些已申请但未分配的内存空间时，会触发缺页异常。此时，操作系统可以在异常处理程序中检查该虚拟地址是否属于已申请的区域，如果是，则为其分配一个物理页，并更新页表项，使其可访问，并返回到用户进程继续执行。如果不是，则说明用户进程访问了非法的地址，应该终止该进程或者采取其他适当的措施。

这样的 Lazy 策略可以避免为用户进程分配不必要的物理内存资源，提高内存利用率。同时，也可以减少页表操作的开销，提高性能。

**2.6 此时页面失效如何表现在页表项(PTE)上？**

根据搜索结果 ，当内存页面被换到磁盘上时，页表项(PTE)上的 present 位会被清零，表示该页不在物理内存中。同时，PTE 上的其他位会被用来存储该页在磁盘上的位置信息，例如 swap 类型和 swap 偏移量。这样，当下次访问该页时，操作系统可以通过 PTE 上的信息找到该页在磁盘上的位置，并将其换入物理内存中。

**3. 双页表与单页表**

**3.1 在单页表情况下，如何更换页表？**

在单页表情况下，更换页表需要修改控制寄存器中的页表基址（CR3），并刷新TLB。这样可以使CPU使用新的页表来进行虚拟地址到物理地址的转换。

**3.2 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）**

单页表情况下，控制用户态无法访问内核页面的方法是设置每个页面的权限位（PTE_U），并检查当前运行模式（CPL）。如果一个页面的PTE_U位为0，表示该页面只能在内核态访问；如果一个页面的PTE_U位为1，表示该页面可以在用户态或内核态访问。当CPU进行地址转换时，会比较当前运行模式和页面的权限位，如果发现权限不匹配，就会触发一个缺页异常（Page Fault）。

**3.3 单页表有何优势？（回答合理即可）**

单页表有以下优势：

- 简化了地址转换的过程，只需要一次查表即可得到物理地址；
- 减少了上下文切换的开销，不需要频繁地更换页表；
- 提高了TLB的命中率，因为TLB中缓存的是全局有效的页面映射；
- 便于实现内核对用户空间的访问，因为内核可以直接使用用户空间的虚拟地址。

**3.4 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？**

双页表实现下，需要更换页表的情况有：

- 进程切换时，需要更换用户空间的页表；
- 进入或退出内核态时，需要更换内核空间的页表；
- 动态加载或卸载模块时，需要更新内核空间的页表；
- 创建或销毁进程时，需要分配或回收用户空间的页表。

假设我写一个单页表操作系统，我会选择在以下情况下更换页表：

- 进程切换时，需要更换整个页表；
- 加载或卸载驱动程序时，需要更新内核部分的页表；
- 创建或销毁进程时，需要分配或回收用户部分的页表。

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

    > 看群里讨论，同学告知框架代码有误，修改了page_table.rs118行的框架代码

2. 此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

    > 无

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

